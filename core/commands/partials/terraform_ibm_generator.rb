# frozen_string_literal: true

# This file is part of MDBCI.
#
# MDBCI is free software: you can redistribute it and/or modify it under the terms
# of the GNU General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# MDBCI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with MDBCI.
# If not, see <https://www.gnu.org/licenses/>.

require 'date'
require 'erb'
require 'socket'
require_relative '../../models/result'
require_relative '../../services/terraform_service'
require_relative '../../services/configuration_reader'

# The class generates the Terraform infrastructure file for IBM Cloud provider
class TerraformIbmGenerator
  # Initializer.
  # @param configuration_id [String] configuration id
  # @param ibm_config [Hash] hash of IBM Cloud configuration
  # @param logger [Out] logger
  # @param configuration_path [String] path to directory of generated configuration
  # @param ssh_keys [Hash] ssh keys info in format { public_key_value, private_key_file_path }
  # @param ibm_service [IbmService] IBM Cloud service
  # @return [Result::Base] generation result.
  def initialize(configuration_id, ibm_config, logger, configuration_path, ssh_keys, ibm_service)
    @configuration_id = configuration_id
    @ibm_config = ibm_config
    @ui = logger
    @configuration_path = configuration_path
    @configuration_labels = { configuration_id: @configuration_id }
    @public_key_value = ssh_keys[:public_key_value]
    @private_key_file_path = ssh_keys[:private_key_file_path]
    @user = ssh_keys[:login]
    @ibm_service = ibm_service
  end

    # Generate a Terraform configuration file.
  # @param node_params [Array<Hash>] list of node params.
  # @param configuration_file_path [String] path to generated Terraform infrastructure file.
  # @return [Result::Base] generation result.
  def generate_configuration_file(node_params, configuration_file_path)
    return Result.error('IBM Cloud is not configured') if @ibm_config.nil?

    file = File.open(configuration_file_path, 'w')
    file.puts(file_header)
    file.puts(provider_resource)
    result = Result.ok('')
    node_params.each do |node|
      result = generate_instance_params(node).and_then do |instance_params|
        print_node_info(instance_params)
        file.puts(instance_resources(instance_params))
        Result.ok('')
      end
      break if result.error?
    end
  rescue StandardError => e
    Result.error(e.message)
  else
    result
  ensure
    file.close unless file.nil? || file.closed?
  end

  # Generate the instance name.
  # @param configuration_id [String] configuration id.
  # @param node_name [String] name of the node.
  # @return [String] generated instance name.
  def self.generate_instance_name(configuration_id, node_name)
    "#{configuration_id}-#{TerraformService.format_string(node_name)}"
  end

  # Log the information about the main parameters of the node.
  # @param node_params [Hash] list of the node parameters.
  def print_node_info(node_params)
    @ui.info("IBM Cloud definition for host: #{node_params[:host]}, "\
             "image:#{node_params[:image]}, machine_type:#{node_params[:machine_type]}")
  end

  def file_header
    <<-HEADER
    # !! Generated content, do not edit !!
    # Generated by MariaDB Continuous Integration Tool (https://github.com/mariadb-corporation/mdbci)
    #### Created #{Time.now} ####
    HEADER
  end

  # Generate provider resource.
  def provider_resource
    <<-PROVIDER
    terraform {
      required_providers {
        ibm = {
          source = "IBM-Cloud/ibm"
          version = ">= 1.12.0"
        }
      }
    }

    provider "ibm" {
      ibmcloud_api_key = "#{@ibm_config['api_key']}"
      region = "#{@ibm_config['region']}"
      zone = "#{@ibm_config['zone']}"
    }
    PROVIDER
  end

  # Generate instance resources.
  # @param instance_params [Hash] list of the instance parameters
  # @return [String] generated resources for instance.
  # rubocop:disable Metrics/MethodLength
  def instance_resources(instance_params)
    template = ERB.new <<-INSTANCE_RESOURCES
    resource "ibm_pi_network" "public_network_<%= name %>" {
      pi_network_name      = "public_<%= instance_name %>"
      pi_cloud_instance_id = "#{@ibm_config['workspace_id']}"
      pi_network_type      = "pub-vlan"
    }

    resource "ibm_pi_key" "ssh_key_<%= name %>" {
      pi_key_name          = "public_key_<%= instance_name %>"
      pi_ssh_key           = "#{@public_key_value}"
      pi_cloud_instance_id = "#{@ibm_config['workspace_id']}"
    }
    
    data "ibm_pi_image" "data_source_image_<%= name %>" {
      pi_cloud_instance_id = "#{@ibm_config['workspace_id']}"
      pi_image_name = "<%= image %>"
    }

    resource "ibm_pi_instance" "<%= name %>" {
      pi_cloud_instance_id = "#{@ibm_config['workspace_id']}"
      pi_instance_name = "<%= instance_name %>"
      <% if memory_size.nil? %> pi_memory = "<%= default_memory_size %>" <% else %> pi_memory = "<%= memory_size %>" <% end %>
      <% if cpu_count.nil? %> pi_processors = "<%= default_cpu_count %>" <% else %> pi_processors = "<%= cpu_count %>" <% end %>
      pi_proc_type = "shared"
      pi_storage_type = "tier3"
      pi_key_pair_name = resource.ibm_pi_key.ssh_key_<%= name %>.name
      pi_image_id = data.ibm_pi_image.data_source_image_<%= name %>.id
      pi_sys_type = "<%= machine_type %>"
      pi_network {
        network_id = resource.ibm_pi_network.public_network_<%= name %>.network_id
      }
    }
      
    output "<%= name %>_network" {
      value = {
        user = "cloud-user"
        private_ip = resource.ibm_pi_instance.<%= name %>.pi_network[0].ip_address
        public_ip = resource.ibm_pi_instance.<%= name %>.pi_network[0].external_ip
        key_file = "<%= key_file %>"
        hostname = "<%= instance_name %>"
      }
    }
    INSTANCE_RESOURCES
    template.result(OpenStruct.new(instance_params).instance_eval { binding })
  end
  # rubocop:enable Metrics/MethodLength

  # Generate a labels block.
  # @param labels [Hash] list of labels in format { label_name: label_value }
  # @return [String] labels block definition.
  def labels_partial(labels)
    template = ERB.new <<-PARTIAL
    PARTIAL
    template.result(binding)
  end

  # Generate a tags block.
  # @param tags [Array<String>] list of tags
  # @return [String] tags block definition.
  def tags_partial(tags)
    "tags = [#{tags.map { |tag| "\"#{tag}\"" }.join(', ')}]"
  end

  # Returns instance network tags for current configuration.
  # Returns generated new network tags if a new vpc resources need to be generated for the current
  # configuration, otherwise returns network tags configured in the mdbci configuration.
  # @return [Array<String>] list of instance tags.
  def instance_tags
  end

  # Generate a instance params for the configuration file.
  # @param node_params [Hash] list of the node parameters
  # @return [Result::Base] instance params
  def generate_instance_params(node_params)
    user = @user
    private_key_file_path = @private_key_file_path
    labels = @configuration_labels.merge(hostname: TerraformService.format_string(Socket.gethostname),
                                         username: TerraformService.format_string(user),
                                         machinename: TerraformService.format_string(node_params[:name]))
    node_params = node_params.merge(
      labels: labels,
      instance_name: self.class.generate_instance_name(@configuration_id, node_params[:name]),

      user: user,
      key_file: private_key_file_path,
    )
    Result.ok(node_params.merge(machine_type: "s1022",
                                volume_type: "tier3",
                                volume_size: 1))

  end
end
