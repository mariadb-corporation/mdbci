# frozen_string_literal: true

require 'date'
require 'fileutils'
require 'json'
require 'pathname'
require 'securerandom'
require 'socket'
require 'erb'
require 'set'
require_relative '../base_command'
require_relative '../../models/configuration'
require_relative '../../services/configuration_generator'
require_relative '../../services/product_attributes'
require_relative '../../services/shell_commands'
require_relative '../../out'
require_relative '../../services/product_registry'

# The class generates the MDBCI configuration for use in pair with the Vagrant backend
# rubocop:disable Metrics/ClassLength
class VagrantConfigurationGenerator < BaseCommand
  CNF_PATH_FILE_NAME = 'cnf_path'

  def self.synopsis
    'Generate a configuration based on the template.'
  end

  def vagrant_file_header
    <<-HEADER
# !! Generated content, do not edit !!
# Generated by MariaDB Continuous Integration Tool (https://github.com/mariadb-corporation/mdbci)
#### Created #{Time.now} ####
    HEADER
  end

  def provider_config
    <<-CONFIG
### Default (VBox, Libvirt) Provider config ###
#######################################################
# Network autoconfiguration
config.vm.network "private_network", type: "dhcp"
config.vm.boot_timeout = 60
    CONFIG
  end

  def vagrant_config_header
    <<-HEADER
### Vagrant configuration block  ###
####################################
Vagrant.configure(2) do |config|
    HEADER
  end

  def vagrant_config_footer
    <<-FOOTER
end
### end of Vagrant configuration block
    FOOTER
  end

  # Vagrantfile for Vbox provider
  # rubocop:disable Metrics/MethodLength
  # The method returns a template; decomposition will complicate the code.
  def get_virtualbox_definition(_cookbook_path, node_params)
    template = ERB.new <<-VBOX
      config.vm.define '<%= name %>' do |box|
        box.vm.box = '<%= box %>'
        box.vm.hostname = '<%= host %>'
        <% if ssh_pty %>
           box.ssh.pty = <%= ssh_pty %>
        <% end %>
        box.vm.provider :virtualbox do |vbox|
          <% if vm_mem %>
             vbox.memory = <%= vm_mem %>
          <% end %>
          vbox.name = "\#{File.basename(File.dirname(__FILE__))}_<%= name %>"
        end
      end
    VBOX
    template.result(OpenStruct.new(node_params).instance_eval { binding })
  end
  # rubocop:enable Metrics/MethodLength

  # Vagrantfile for Libvirt provider
  # rubocop:disable Metrics/MethodLength
  # The method returns a template; decomposition will complicate the code.
  def get_libvirt_definition(_cookbook_path, path, node_params)
    node_params = node_params.merge(expand_path: File.expand_path(path), ipv6: @env.ipv6)
    template = ERB.new <<-LIBVIRT
      #  --> Begin definition for machine: <%= name %>
      config.vm.define '<%= name %>' do |box|
        box.vm.box = '<%= box %>'
        box.vm.hostname = '<%= host %>'
        <% if ssh_pty %>
          box.ssh.pty = <%= ssh_pty %>
        <% end %>
        <% if ipv6 %>
          box.vm.network :public_network, :dev => 'virbr0', :mode => 'bridge', :type => 'bridge'
        <% end %>
        box.vm.provider :libvirt do |qemu|
          qemu.driver = 'kvm'
          qemu.cpu_mode = 'host-passthrough'
          qemu.cpus = <%= vm_cpu %>
          qemu.memory = <%= vm_mem %>
        <% if disk_bus %>
          qemu.disk_bus = '<%= disk_bus %>'
        <% end %>
        end
        <% if platform == 'ubuntu' && platform_version == 'bionic' %>
        # Fix DNS bug
        script = <<-SCRIPT
          echo Fixing the netplan configuration
          sed -i '/nameservers:/d' /etc/netplan/01-netcfg.yaml
          sed -i '/addresses:/d' /etc/netplan/01-netcfg.yaml
          netplan apply
          echo Fixing systemd-resolved configuration
          echo "
[Resolve]
DNS=1.1.1.1
FallbackDNS=
Domains=
LLMNR=no
MulticastDNS=no
DNSSEC=no
Cache=no
DNSStubListener=yes" > /etc/systemd/resolved.conf
          systemctl restart systemd-resolved
          systemd-resolve --status
        SCRIPT

        box.vm.provision "shell", inline: script
        <% end %>
      end #  <-- End of Qemu definition for machine: <%= name %>
    LIBVIRT
    template.result(OpenStruct.new(node_params).instance_eval { binding })
  end
  # rubocop:enable Metrics/MethodLength


  # Check for the box emptiness and existence of a box in the boxes list.
  #
  # @param box [String] name of the box
  def box_valid?(box)
    return false if box.empty?

    !@boxes.get_box(box).nil?
  end

  # Make a hash list of node parameters by a node configuration and
  # information of the box parameters.
  #
  # @param node [Array] information of the node from configuration file
  # @param box_params [Hash] information of the box parameters
  # @return [Hash] list of the node parameters.
  def make_node_params(node, box_params)
    symbolic_box_params = Hash[box_params.map { |k, v| [k.to_sym, v] }]
    {
      name: node[0].to_s,
      host: node[1]['hostname'].to_s,
      vm_mem: node[1]['memory_size'].nil? ? '1024' : node[1]['memory_size'].to_s,
      vm_cpu: (@env.cpu_count || node[1]['cpu_count'] || '1').to_s
    }.merge(symbolic_box_params)
  end

  # Log the information about the main parameters of the node.
  #
  # @param node_params [Hash] list of the node parameters
  # @param box [String] name of the box.
  def print_node_info(node_params, box)
    @ui.info("Requested memory #{node_params[:vm_mem]}")
    @ui.info("Requested number of CPUs #{node_params[:vm_cpu]}")
    @ui.info("config.ssh.pty option is #{node_params[:ssh_pty]} for a box #{box}") unless node_params[:ssh_pty].nil?
  end

  # Generate a node definition for the Vagrantfile, depending on the provider
  # uses the appropriate generation method.
  #
  # @param node_params [Hash] list of the node parameters
  # @param cookbook_path [String] path of the cookbook
  # @param path [String] path of the configuration file
  # @return [String] node definition for the Vagrantfile.
  def generate_node_defenition(node_params, cookbook_path, path)
    case node_params[:provider]
    when 'virtualbox'
      get_virtualbox_definition(cookbook_path, node_params)
    when 'libvirt'
      get_libvirt_definition(cookbook_path, path, node_params)
    else
      @ui.warning('Configuration type invalid! It must be vbox libvirt type. Check it, please!')
      ''
    end
  end

  # Make a list of node parameters, create the role and node_config files, generate
  # node definition for the Vagrantfile.
  #
  # @param node [Array] internal name of the machine specified in the template
  # @param path [String] path of the configuration file
  # @param cookbook_path [String] path of the cookbook
  # @return [Result<String>] node definition for the Vagrantfile.
  # rubocop:disable Metrics/MethodLength
  # Further decomposition of the method will complicate the code.
  def node_definition(node, path, cookbook_path)
    box = node[1]['box'].to_s
    node_params = make_node_params(node, @boxes.get_box(box))
    @configuration_generator.generate_node_info(node, node_params, @product_registry).and_then do |info|
      @configuration_generator.create_role_files(path, info[:node_params][:name], info[:role_file_content])
      if box_valid?(info[:box])
        Result.ok(generate_node_defenition(info[:node_params], cookbook_path, path))
      else
        @ui.warning("Box #{box} is not installed or configured ->SKIPPING")
        Result.ok('')
      end
    end
  end
  # rubocop:enable Metrics/MethodLength


  # Make a hash list of node parameters by a node configuration and
  # information of the box parameters.
  #
  # @param node [Array] information of the node from configuration file
  # @param box_params [Hash] information of the box parameters
  # @return [Hash] list of the node parameters.
  def make_node_params(node, box_params)
    symbolic_box_params = box_params.transform_keys(&:to_sym)
    symbolic_box_params.merge!(
        {
            name: node[0].to_s,
            host: node[1]['hostname'].to_s,
            vm_mem: node[1]['memory_size'].nil? ? '1024' : node[1]['memory_size'].to_s,
            vm_cpu: (@env.cpu_count || node[1]['cpu_count'] || '1').to_s
        }
    )
  end

  # Generate a Vagrantfile.
  #
  # @param path [String] path of the configuration file
  # @param config [Hash] value of the configuration file
  # @param provider [String] provider name of the nodes
  # @param cookbook_path [String] path of the cookbook.
  # rubocop:disable Metrics/MethodLength
  # The method performs a single function; decomposition of the method will complicate the code.
  def generate_vagrant_file(path, config, provider, cookbook_path)
    vagrant = File.open(File.join(path, 'Vagrantfile'), 'w')
    vagrant.puts vagrant_file_header, vagrant_config_header
    @ui.info('Generating libvirt/VirtualBox configuration')
    vagrant.puts provider_config
    config.map do |node|
      @ui.info("Generating node definition for [#{node[0]}]")
      node_definition = node_definition(node, path, cookbook_path)
      raise node_definition.error if node_definition.error?

      vagrant.puts node_definition.value
    end
    vagrant.puts vagrant_config_footer
    vagrant.close
    SUCCESS_RESULT
  rescue RuntimeError => e
    @ui.error(e.message)
    @ui.error('Configuration is invalid')
    vagrant.close
    FileUtils.rm_rf(path)
    ERROR_RESULT
  end
  # rubocop:enable Metrics/MethodLength

  # Check parameters and generate a Vagrantfile.
  #
  # @param path [String] path of the configuration file
  # @param config [Hash] value of the configuration file
  # @param provider [String] provider name of the nodes
  # @return [Result::Base] SUCCESS_RESULT if the execution of the method passed without errors,
  # otherwise - ERROR_RESULT or ARGUMENT_ERROR_RESULT.
  def generate(path, config, provider)
    # TODO: MariaDb Version Validator
    FileUtils.mkdir_p(path)
    checks_result = config.check_nodes_names
    return checks_result if checks_result.error?

    cookbook_path = if config.cookbook_path.nil?
                      File.join(@env.mdbci_dir, 'assets', 'chef-recipes', 'cookbooks') # default cookbook path
                    else
                      config.cookbook_path
                    end
    @ui.info("Global cookbook_path = #{cookbook_path}")
    @ui.info("Nodes provider = #{provider}")
    return ERROR_RESULT if generate_vagrant_file(path, config, provider, cookbook_path) == ERROR_RESULT
    return SUCCESS_RESULT unless File.size?(File.join(path, 'Vagrantfile')).nil?

    @ui.error('Generated Vagrantfile is empty! Please check configuration file and regenerate it.')
    ERROR_RESULT
  end

  # Generate provider and template files in the configuration directory.
  #
  # @param path [String] configuration directory
  # @param provider [String] nodes provider
  # @raise RuntimeError if provider or template files already exists.
  def generate_provider_and_template_files(path, provider)
    provider_file = Configuration.provider_path(path)
    template_file = Configuration.template_path(path)
    product_registry_path = Configuration.product_registry_path(path)
    raise 'Configuration \'provider\' file already exists' if File.exist?(provider_file)
    raise 'Configuration \'template\' file already exists' if File.exist?(template_file)

    File.open(provider_file, 'w') { |f| f.write(provider) }
    File.open(template_file, 'w') { |f| f.write(File.expand_path(@env.template_file)) }
    @product_registry.save_registry(product_registry_path)
  end

  # Check that all boxes specified in the the template are identical.
  #
  # @param providers [Array] list of nodes providers from config file
  # @return [Bool] false if unable to detect the provider for all boxes or
  # there are several providers in the template, otherwise - true.
  def check_providers(providers)
    if providers.empty?
      @ui.error('Unable to detect the provider for all boxes. Please fix the template.')
      return false
    end
    unique_providers = Set.new(providers)
    return true if unique_providers.size == 1

    @ui.error("There are several node providers defined in the template: #{unique_providers.to_a.join(', ')}.\n"\
              'You can specify only nodes from one provider in the template.')
    false
  end

  # Check that all boxes specified in the the template are exist in the boxes.json
  # and all providers specified in the the template are identical.
  # Save provider to the @provider if check successful.
  #
  # @param configs [Array] list of nodes specified in template
  # @return [Bool] true if the result of passing all checks successful, otherwise - false.
  def load_nodes_provider_and_check_it(configs)
    nodes = configs.map { |node| %w[aws_config cookbook_path].include?(node[0]) ? nil : node }.compact.to_h
    providers = nodes.map do |node_name, node_params|
      box = node_params['box']

      begin
        box_params = @boxes.get_box(box)
      rescue StandardError
        @ui.error("Box #{box} is not found")
        return false
      end
      box_params['provider'].to_s
    end
    return false unless check_providers(providers)

    @provider = providers.first
    true
  end

  # Set required parameters as instance variables,
  # defines the path for generating the configuration, parse the config JSON-file.
  #
  # @param name [String] name of the configuration file
  # @return [Result::Base<ConfigurationTemplate>] path and config hash
  def setup_command(name)
    @boxes = @env.box_definitions
    @configuration_generator = ConfigurationGenerator.new(@ui, @env)
    @configuration_path = name.nil? ? File.join(Dir.pwd, 'default') : File.absolute_path(name.to_s)
    @product_registry = ProductRegistry.new
    ConfigurationTemplate.from_path(File.expand_path(@env.template_file))
  end

  # Generate a configuration.
  #
  # @param name [String] name of the configuration file
  # @return [Result::Base] exit code for the command execution
  def execute(name)
    setup_command(name).and_then do |config|
      nodes_checking_result = load_nodes_provider_and_check_it(config)
      return ARGUMENT_ERROR_RESULT unless nodes_checking_result

      generate_result = generate(@configuration_path, config, @provider)
      return generate_result unless generate_result == SUCCESS_RESULT

      @ui.info "Generating config in #{@configuration_path}"
      generate_provider_and_template_files(@configuration_path, @provider)
      SUCCESS_RESULT
    end
  end
end
# rubocop:enable Metrics/ClassLength
